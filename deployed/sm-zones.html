<!DOCTYPE HTML>
<html>
	<head>
		<script src="https://cdn.jsdelivr.net/npm/echarts@5.2.0/dist/echarts.min.js"></script>
		<link rel="stylesheet" href="sm-zones.css"></script>
		<script type="text/javascript" src="https://cdn.jsdelivr.net/jquery/latest/jquery.min.js"></script>
		<script type="text/javascript" src="https://cdn.jsdelivr.net/momentjs/latest/moment.min.js"></script>
		<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/daterangepicker/daterangepicker.min.js"></script>
		<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/daterangepicker/daterangepicker.css" />
	</head>

	<body>
		<div class="daterange">
			&#128198;&nbsp;&nbsp;<input class="dateinput" type="text" name="daterange"/>
		</div>&nbsp;
		<div id="chart" class="chart"></div>
		<script type="text/javascript">

			// Begin setup
			const READ_ONLY_TOKEN = "BBAU-MRoCiUPLmWFdZj8kvowA6QLepOQN59";
			const DEVICE_NAME = "stoneleigh-sm-kanzi-block";
			const VARIABLES = ["av-20cm", "av-40cm", "av-60cm"];
			// Optional
			const N_RESULTS_PER_PAGE = 10000; // Easier to work with a single page
			const RETURN_TYPE = "json";
			// End setup

			function initDate() {
				// Default 7 day view
				var startDate = moment().subtract(7, 'days');
				var endDate = moment();
				$('input[name="daterange"]').daterangepicker({
					timePicker: true,
					opens: 'left',
					startDate: startDate,
					endDate: endDate,
					locale: {
						format: "DD/MM/YY hh:mm A"
					}
				}, function updateChart(start, end, label) {
					var date = {
						start: start.valueOf(),
						end: end.valueOf()
					};
					getData(date).then((response) => {
						renderChart(response);
					});
				});
				return {
					start: startDate.valueOf(),
					end: endDate.valueOf()
				};
			};

			var date = initDate();

			async function getData(date) {
				// TODO add error handling here
				try {
					const urls = VARIABLES.map(function(_, i) {
						var url = "https://industrial.api.ubidots.com/api/v1.6/devices/" +
									DEVICE_NAME + "/" + VARIABLES[i] + "/values/?start=" +
									date.start + "&end=" + date.end +
									"&page_size=" + N_RESULTS_PER_PAGE + "&format=" + RETURN_TYPE;
						return url;
					});
					const request = Array.from(Array(urls.length)).map(async function(_, i) {
						const req = await fetch(urls[i], {
							method: "GET",
							headers: {"X-Auth-Token": READ_ONLY_TOKEN}
						});
						return req.json();
					});

					const response = await Promise.all(request);
					return response;
				} catch (error) {
					console.log(error);
				}

			}
			function renderChart(response){
				// TODO needs better error handling
				var series = response.map(function(_, i) {
					var data = response[i].results.map(function (value, index) {
						var date = new Date(value.timestamp);
						return [date, value.value];
					});
					return data;
				});

				var chartDom = document.getElementById('chart');
				var chart = echarts.init(chartDom);
				
				// Resize chart with window size
				window.onresize = function() {
					chart.resize();
				};

				var options = {
					tooltip: {
						trigger: 'axis',
						axisPointer: {
							type: 'cross'
						}
					},
					toolbox: {
						show: true,
						feature: {
							saveAsImage: {},
							dataZoom: {},
							restore: {}
						}
					},
					legend: {
						show: true,
					},
					dataZoom: [
						{
							type: 'inside',
							throttle: 50
						}
					],
					xAxis: {
						label: "Date",
						type: 'time',
						splitArea: {
							show: true
						}
					},
					yAxis: {
						label: "VWC (%)",
						type: 'value',
						min: 0,
						max: 100
					},
					series: [
					{
						name: "Field Capacity",
						type: 'line',
						data: [],
						markLine: {
							label: {
								formatter: "Field Capacity",
								position: "insideEndBottom"
							},
							lineStyle: {
								width: 2,
								color: 'rgba(70, 70, 255, 1)'
							},
							data: [{
								yAxis: 72
							}]
						},
						markArea: {
							label: {
								show: true,
								position: 'inside',
								color: '#000'
							},
							data:[
								[{
									name: "Very wet",
									itemStyle: {
										color: 'rgba(55, 143, 255, 0.4)'
									},
									yAxis: 72
								},
								{
									yAxis: 100
								}]
							]
						}
					},
					{
						name: "Wilting Point",
						type: 'line',
						data: [],
						markLine: {
							label: {
								formatter: "Wilting Point",
								position: "insideEndTop"
							},
							lineStyle: {
								width: 2,
								color: 'rgba(255, 70, 95, 1)'
							},
							data: [{
								yAxis: 23
							}]
						},
						markArea: {
							label: {
								show: true,
								position: 'inside',
								color: '#000'
							},
							data:[
								[{
									name: "Very dry",
									itemStyle: {
										color: 'rgba(255, 173, 177, 0.4)'
									},
									yAxis: 0
								},
								{
									yAxis: 23
								}],
							]
						}
					},
					{
						name: VARIABLES[0],
						type: 'line',
						data: series[0].reverse(), // Reverse array as last value comes first
					},
					{
						name: VARIABLES[1],
						type: 'line',
						data: series[1], 
					},
					{
						name: VARIABLES[2],
						type: 'line',
						data: series[2], // Reverse array as last value comes first
					},
					],
				};

				options && chart.setOption(options);
			}

			getData(date).then((response) => {
				renderChart(response);
			});
		</script>
	</body>
</html>
